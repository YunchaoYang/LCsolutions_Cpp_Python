C+中常用的两种创建动态数组方法：new()和vector.

1.new 方法：
```cpp
int *p=new int[num];
```
创建一个容量为num的int型数组，num可来自外部输入、函数传递等，
int型指针p指向动态数组的首地址，在动态数组创建完成后，我们可以下标访问数组元素：p[0],p[1]...，
但是new方法不能创建二维数组，只能创建一维数组，并且创建后数据元素操作缺乏灵活性；用得最多的地方当属创建链表结点；

2. vector容器：能够存放任意类型的动态数组，

C++标准容器分类表
标准容器类

特点

| 顺序性容器 | Description |
|--------- | -------- |
| vector | 从后面快速的插入与删除，直接访问任何元素 |
| deque | 从前面或后面快速的插入与删除，直接访问任何元素 |
| list | 双链表，从任何地方快速插入与删除 |

| 关联容器| Description|
|--------- | -------- |
set | 快速查找，不允许重复值
multiset | 快速查找，允许重复值
map | 一对多映射，基于关键字快速查找，不允许重复值
multimap | 一对多映射，基于关键字快速查找，允许重复值

# vector or array 
* 数组：底层数据类型，存放在栈中，其内存的分配和释放完全由系统自动完成，效率最高
* 动态数组：程序员由new运算符创建的，存放在堆区，需要delete运算符人工释放，否则会造成内存泄露
* vector：存放在堆中，由STL库中程序负责内存的分配和释放，使用方便
vector效率低原因：vector的动态自增，并不是在原空间之后接续新空间，而是在原空间不够使用时，以原空间大小的两倍另外配置一块大空间，然后将原内容拷贝过来，再在新拷贝的原内容之后构造新元素，并释放原空间。这是vector效率低的主要原因。
注意：对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器都失效了。此外，还要注意size和capacity的区别，size指容器当前拥有的元素个数，capacity指容器在必须分配新存储空间之前可以存储的元素总数，capacity总是大于或等于size。下图是vector的构造和内存管理示意图（来自STL源码剖析）

2.1预备知识-程序的内存分配
一个由C/C++编译的程序占用的内存分为以下几个部分

1. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。是一种线性结构，其操作方式类似于数据结构中的栈，操作速度较快。但程序员是无法控制。

2. 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，是一种链式结构，分配方式倒是类似于链表，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

3. 全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 

4. 文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放

5.程序代码区—存放函数体的二进制代码。
https://blog.csdn.net/chhuach2005/java/article/details/21281933
